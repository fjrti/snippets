通用的makefile文件

1. 定义变量的方式：在这个框架中，使用了两种方式，一种是：=，也称立即赋值，= 称为延后赋值，
   这两种赋值方式在于立即赋值直接将变量的值赋给变量，而延后赋值相当于变量替换，
   说的通俗一点就是立即赋值：=相当于C语言的赋值，延后赋值相当于C语言的宏定义。
   一般来说，延后赋值相当于宏，因此可能会带来递归，多次执行等问题，因此,延后赋值需要慎用。
   
2. 关于依赖：在这里，依赖实际上除了.o依赖与.c以外，没有写.c和.h的依赖关系，这个实际上依靠-include $(DEP_$(d)和GCC的-MD来实现。
   看一下Makefile的执行顺序:
   (1) Makefile首先会构造一张有向无环图DAG，然后依据这个有向无环图构造目标文件;
   (2) 根据 $(TARGET): $(OBJ_DIR) $(OBJS) $(LIBS_LIST) 首先生成OBJ_DIR，用于存放.o文件和库文件;
   (3) 生成$(OBJS),这个是依据$(OBJ_DIR)/%.o: %.c依赖关系，编译本目录的C文件生成.o到OBJ_DIR目录下;
   (4) 生成$(LIBS_LIST),这个是每个子目录生成的静态库文件，查看LIBS_LIST在每个子目录下的定义LIBS_LIST := $(LIBS_LIST) $(LIBRARY)，而各个子目录下的库文件是由各个子目录的.o文件生成，所以又会去生成各个子目录的.o文件。
   (5) 根据TARGET的Action，生成最终的目标文件。
   这里有一个隐含的技巧就是，每次编译生成.o的时候由于加了-MD参数，因此都会生成相应的.d文件，而本目录和子目录都有这样的include，如：- include $(OBJS:.o=.d) , -include $(DEP_$(d)),而Makefile有个特性，就是每次include中的文件更新时都会重新去Make，因此，一旦include文件更新整个 Make过程要重新检查依赖，这样第一次Make后的，实际上第二次Make并不会去更新任何目录，只是include把那些依赖包含进来了，重新DAG 图，而依赖关系格式如下:****.c: ****.h ****.h，具体可以用自己的编译器试一把，至此Makefile才真正完整。

3. 关于每次进子目录的.mk文件中的头三行
   sp := $(sp).x #just a suffix, reflects the depth of the subdir
   dirstack_$(sp) := $(d) #save the dir path of high level
   d := $(dir) #set current directory
   和尾两行
   d   :=  $(dirstack_$(sp))
   sp  :=  $(basename $(sp))
   实际上是实现了一个堆栈，用来压入上一级的目录和恢复上一级的目录的，这个是用在子目录下还包含子目录的情况的。大家可以去自己揣摩一下，实现还是非常巧妙的。
   为什么需要每一级.mk都知道本目录的路径？
   避免在不同的目录下包含相同的头文件，而导致搜索路径-I参数不好配置，注意每个子目录的CFLAGS_LOCAL := -I$(d) ,是从当前的目录下搜索的。

4. 在使用的时候注意Action前的空格需要改成Tab。
